diff --git a/rust/kernel/timer.rs b/rust/kernel/timer.rs
new file mode 100644
index 000000000..5c7902625
--- /dev/null
+++ b/rust/kernel/timer.rs
@@ -0,0 +1,204 @@
+use crate::bindings::{
+    timer_list, lock_class_key,
+    del_timer, mod_timer,
+    init_timer_key,
+};
+use crate::CStr;
+
+use alloc::boxed::Box;
+use core::pin::Pin;
+use core::mem::MaybeUninit;
+use core::marker::PhantomPinned;
+use core::ops::DerefMut;
+
+/// # Safety
+/// It is highly recommeneded to use this only in const context
+macro_rules! memoffset {
+    ($base:ty => $($field:ident).+) => {
+        unsafe {
+            // Mostly inspired by https://github.com/Gilnaa/memoffset
+
+            // SAFETY:
+            // 0. If are running in const context, any UB should become compilation error.
+            // 1. We are creating pointer to uninitialized memory and dereferencing it.
+            //    This is an UB, but we are not reading nor writing to such memory.
+            // 2. core::ptr::offset_from requires following:
+            //    - pointers must point to same allocated object.
+            //      It's true, since we are using single MaybeUninit::uninit()
+            //    - pointers must be derived from a pointer to the same object.
+            //      Same: both are derived from base pointer.
+            //    - distance between the pointers, in bytes, cannot overflow an isize
+            //      Let's hope that no one will create single struct lareger than isize::MAX.
+            //    - distance between the pointers, in bytes, must be an exact multiple of the size of T
+            //      We are casting them to *const u8, so it's true.
+            //    - The distance being in bounds cannot rely on "wrapping around" the address space.
+            //      We do not rely on that.
+
+            // Firstly, create uninitialized $base.
+            let base: MaybeUninit<$base> = MaybeUninit::uninit();
+            let base: *const $base = base.as_ptr();
+
+            // Then get pointers to a field.
+            // This is an UB, since we are creating reference to an uninitialized memory.
+            let field = core::ptr::addr_of!((&*base)$(.$field)*);
+
+            // Cast everything into u8 pointers, so all units are bytes.
+            let base = base as *const u8;
+            let field = field as *const u8;
+
+            // Finally, compute the offset
+            field.offset_from(base)
+        }
+    }
+}
+
+pub use crate::bindings::{
+    TIMER_DEFERRABLE as DEFERRABLE,
+    TIMER_IRQSAFE as IRQSAFE,
+    TIMER_PINNED as PINNED,
+};
+
+pub struct Timer<'a, F=fn()> {
+    // Timer is Unpin, since list have a pointer to callback function. which is stored in the same
+    // struct. Probably in future we can implement Unpin for Timer when F is zero-sized-type.
+    _pinned: PhantomPinned,
+    // FIXME: We should wrap list into Rc, since it can be used while callback is running
+    // In such scenario we will create and use two mutable references to same timer_list.
+    list: MaybeUninit<timer_list>,
+    callback: F,
+    name: CStr<'a>,
+    key: MaybeUninit<lock_class_key>,
+}
+
+// FIXME: It is not safe.
+unsafe impl<'a, F> Send for Timer<'a, F> {}
+unsafe impl<'a, F> Sync for Timer<'a, F> {}
+
+pub struct TimerArgs<'a, F> {
+    pub name: CStr<'a>,
+    pub callback: F,
+    pub flags: u32
+}
+
+// TODO: Builder pattern
+
+impl<'a, F> Timer<'a, F> where F: Fn() {
+    const LIST_OFFSET: isize = memoffset!(Self => list);
+    unsafe extern "C" fn wrapper(list: *mut timer_list) {
+        let base = (list as *const u8).offset(-Self::LIST_OFFSET);
+        // FIXME: Is it safe?
+        let this = &*(base as *const Self);
+        (this.callback)();
+    }
+
+    /// # Safety
+    /// Caller must ensure that place contains correct struct, with timer and key uninitialized.
+    unsafe fn initialize(self: Pin<&mut Self>, flags: u32) -> Pin<&mut Self> {
+        // FIXME: It's better to avoid using as_ptr() and then casting to *mut T
+        //        But Pin protects us from accessing &mut Self directly.
+        init_timer_key(
+            /* timer */ self.list.as_ptr() as *mut _,
+            /* func  */ Some(Self::wrapper),
+            /* flags */ flags,
+            /* name  */ self.name.as_ptr() as *const i8,
+            /* key   */ self.key.as_ptr() as *mut _,
+        );
+        self
+    }
+
+    /// # Safety
+    /// This function returns Timer without initializing it's fields.
+    /// Caller MUST call .initialize() before using timer.
+    unsafe fn new_uninitialized(args: TimerArgs<'a, F>) -> (Self, u32) {
+        let res = Self {
+            _pinned: PhantomPinned::default(),
+            list: MaybeUninit::uninit(),
+            name: args.name,
+            key: MaybeUninit::uninit(),
+            callback: args.callback
+        };
+        (res, args.flags)
+    }
+
+    /// Creates timer inside of pinned MaybeUninit.
+    ///
+    /// # Safety
+    /// Caller must drop previous timer if there is any.
+    pub unsafe fn initialize_in<P>(mut place: Pin<P>, args: TimerArgs<'a, F>)
+        where P: DerefMut<Target = MaybeUninit<Self>>
+    {
+        // SAFETY: We MUST call .initialize() after pinning:
+        let (uninit, flags) = Self::new_uninitialized(args);
+
+        place.set(MaybeUninit::new(uninit));
+        let result: Pin<&mut MaybeUninit<Self>> = place.as_mut();
+
+        // SAFETY:
+        // 1. We just initialized MaybeUninit, so we can dereference pointer.
+        // 2. Map function is good in terms of "map_unchecked_mut".
+        let result: Pin<&mut Self> = result.map_unchecked_mut(|x| &mut *x.as_mut_ptr());
+
+        result.initialize(flags);
+    }
+
+    /// Creates timer inside of pinned option, dropping and overwriting previous timer if any.
+    pub fn in_option<'b, P>(place: &'b mut Pin<P>, args: TimerArgs<'a, F>) -> Pin<&'b mut Self>
+        where P: DerefMut<Target = Option<Self>>
+    {
+        unsafe {
+            // SAFETY: We MUST call .initialize() after pinning:
+            let (uninit, flags) = Self::new_uninitialized(args);
+
+            place.set(Some(uninit));
+            let result: Pin<&mut Option<Self>> = place.as_mut();
+
+            // SAFETY:
+            // 1. We just initialized Option, so we can unsafely unwrap it.
+            //    FIXME: Waiting fot [option_result_unwrap_unchecked] stabilized
+            //    [option_result_unwrap_unchecked]: https://github.com/rust-lang/rust/issues/63291
+            // 2. Map function is good in terms of "map_unchecked_mut".
+            let result: Pin<&mut Self> = result
+                .map_unchecked_mut(|x| x.as_mut().unwrap());
+
+            result.initialize(flags)
+        }
+    }
+
+    /// Creates timer on heap and returns it.
+    ///
+    /// Eaisest and safest way to create a timer.
+    pub fn boxed(args: TimerArgs<'a, F>) -> Pin<Box<Self>> {
+        unsafe {
+            let (uninit, flags) = Self::new_uninitialized(args);
+
+            let mut result: Pin<Box<Self>> = Box::pin(uninit);
+            result.as_mut().initialize(flags);
+
+            result
+        }
+    }
+
+    /// Returns was the timer active.
+    /// ie. modifying inactive timer will return false.
+    pub fn modify(self: Pin<&mut Self>, expires: u64) -> bool {
+        let res = unsafe {
+            // SAFETY: We won't move any data
+            let this = self.get_unchecked_mut();
+            // SAFETY: self.list is initialized
+            mod_timer(this.list.as_mut_ptr(), expires)
+        };
+        res != 0
+    }
+}
+
+impl<F> Drop for Timer<'_, F> {
+    fn drop(&mut self) {
+        unsafe {
+            let timer_list = self.list.as_mut_ptr();
+            del_timer(timer_list);
+            core::ptr::drop_in_place(timer_list);
+
+            core::ptr::drop_in_place(self.key.as_mut_ptr());
+        }
+    }
+}
