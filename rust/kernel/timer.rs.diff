diff --git a/rust/kernel/timer.rs b/rust/kernel/timer.rs
index 92ab8ee79b5a..eded0ca5f2a9 100644
--- a/rust/kernel/timer.rs
+++ b/rust/kernel/timer.rs
@@ -1,20 +1,17 @@
-use crate::bindings::{
-    timer_list, lock_class_key,
-    del_timer_sync, mod_timer,
-    init_timer_key,
-};
+use crate::bindings::{del_timer_sync, init_timer_key, lock_class_key, mod_timer, timer_list};
 use crate::CStr;
 
 use alloc::boxed::Box;
-use core::pin::Pin;
-use core::mem::MaybeUninit;
+use core::cell::UnsafeCell;
 use core::marker::PhantomPinned;
+use core::mem::MaybeUninit;
 use core::ops::DerefMut;
+use core::pin::Pin;
 
 pub struct TimerBuilder<'a, C> {
     pub name: CStr<'a>,
     pub callback: C,
-    pub flags: u32
+    pub flags: u32,
 }
 
 #[macro_export]
@@ -23,33 +20,34 @@ macro_rules! timer {
         $crate::timer::TimerBuilder::new(
             // C-macro uses variable name as timer name.
             // In Rust we will be using filename and line instead
-            /* name */ $crate::cstr!(concat!(
-                core::file!(),
-                "_",
-                core::line!()
-            )),
-            $callback
+            $crate::cstr!(concat!(core::file!(), "_", core::line!())),
+            $callback,
         )
-    }
+    };
 }
 
+/// TimerBuilder allows
+/// # Example
 /// ```rust
-/// let mut timer: Pin<Box<Timer<_>> =
-///     TimerBuilder::new(
-///         cstr!("HelloTimer"),
-///         || println!("Hello from timer!")
-///     )
+/// fn handler() {
+///     println!("Hello from timer!");
+/// }
+/// let mut timer: Pin<Box<Timer<'static, fn()>> =
+///     TimerBuilder::new(cstr!("HelloTimer"), handler)
 ///     .irqsafe()
 ///     .boxed();
 /// timer.modify(jiffies() + 5*HZ)
 /// ```
-impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
+impl<'a, C> TimerBuilder<'a, C>
+where
+    C: TimerCallback,
+{
     /// Creates new builder with provided name and callback.
     pub fn new(name: CStr<'a>, callback: C) -> Self {
         Self {
             name,
             callback,
-            flags: 0
+            flags: 0,
         }
     }
 
@@ -64,8 +62,8 @@ impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
 
     /// An irqsafe timer is executed with IRQ disabled and it's safe to wait for
     /// the completion of the running instance from IRQ handlers, for example,
-    /// by calling del_timer_sync(). FIXME!
-    /// 
+    /// by calling del_timer_sync(). FIXME: we have no del_timer_sync
+    ///
     /// Note: The irq disabled callback execution is a special case for
     /// workqueue locking issues. It's not meant for executing random crap
     /// with interrupts disabled. Abuse is monitored!
@@ -79,8 +77,8 @@ impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
     /// # Safety
     /// Caller must drop previous timer if there is any.
     pub unsafe fn in_uninit<'b, P>(self, place: &'b mut Pin<P>) -> Pin<&'b mut Timer<'a, C>>
-        where
-            P: DerefMut<Target = MaybeUninit<Timer<'a, C>>>,
+    where
+        P: DerefMut<Target = MaybeUninit<Timer<'a, C>>>,
     {
         // SAFETY: We MUST call .initialize() after pinning:
         let (uninit, flags) = Timer::new_uninitialized(self);
@@ -91,8 +89,7 @@ impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
         // SAFETY:
         // 1. We just initialized MaybeUninit, so we can dereference pointer.
         // 2. Map function is good in terms of "map_unchecked_mut".
-        let result: Pin<&mut _> = result
-            .map_unchecked_mut(|x| &mut *x.as_mut_ptr());
+        let result: Pin<&mut _> = result.map_unchecked_mut(|x| &mut *x.as_mut_ptr());
 
         result.initialize(flags)
     }
@@ -118,7 +115,8 @@ impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
     /// }
     /// ```
     pub fn in_option<'b, P>(self, place: &'b mut Pin<P>) -> Pin<&'b mut Timer<'a, C>>
-        where P: DerefMut<Target = Option<Timer<'a, C>>>
+    where
+        P: DerefMut<Target = Option<Timer<'a, C>>>,
     {
         unsafe {
             // SAFETY: We MUST call .initialize() after pinning:
@@ -132,8 +130,7 @@ impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
             //    FIXME: Waiting for [option_result_unwrap_unchecked] stabilized
             //    [option_result_unwrap_unchecked]: https://github.com/rust-lang/rust/issues/63291
             // 2. Map function is good in terms of "map_unchecked_mut".
-            let result: Pin<&mut _> = result
-                .map_unchecked_mut(|x| x.as_mut().unwrap());
+            let result: Pin<&mut _> = result.map_unchecked_mut(|x| x.as_mut().unwrap());
 
             result.initialize(flags)
         }
@@ -156,15 +153,15 @@ impl<'a, C> TimerBuilder<'a, C> where C: TimerCallback {
     }
 }
 
-/// This trait may be extended in future to give more features.
-/// So it's not recommended to implement it directly.
-/// Better to use closures or any other types that implement FnMut().
 pub trait TimerCallback: Send + Sync + Sized {
-    fn invoke(&mut self);
+    fn invoke(&mut self, timer: Pin<&mut Timer<'_, Self>>);
 }
 
-impl<F> TimerCallback for F where F: Send + Sync + Sized + FnMut() {
-    fn invoke(&mut self) {
+impl<F> TimerCallback for F
+where
+    F: Send + Sync + Sized + FnMut(),
+{
+    fn invoke(&mut self, _timer: Pin<&mut Timer<'_, Self>>) {
         (self)()
     }
 }
@@ -175,8 +172,8 @@ pub struct Timer<'a, C> {
     // which is stored in the same struct.
     _pinned: PhantomPinned,
     list: MaybeUninit<timer_list>,
-    // SAFETY: Do not use this field while there is possibility for callback to be run.
-    callback: C,
+    // UnsafeCell since C callbacks does not fit well with Rust borrowing rules
+    callback: UnsafeCell<C>,
     name: CStr<'a>,
     key: MaybeUninit<lock_class_key>,
 }
@@ -185,23 +182,21 @@ pub struct Timer<'a, C> {
 unsafe impl<'a, C> Send for Timer<'a, C> where C: Send {}
 unsafe impl<'a, C> Sync for Timer<'a, C> where C: Sync {}
 
-impl<'a, C> Timer<'a, C> where C: TimerCallback {
+impl<'a, C> Timer<'a, C>
+where
+    C: TimerCallback,
+{
     unsafe extern "C" fn wrapper(list: *mut timer_list) {
         let container: *const Self = crate::container_of!(list, Self, list);
-        let offset_in_bytes = crate::offset_of!(Self, callback);
-        let callback: *const C = (container as *const u8).offset(offset_in_bytes) as *const _;
 
-        // SAFETY:
-        // Timer is owned somewhere else and thus be modified unexpectedly.
-        // Here we are creating reference to the field bypassing Rust's borrowing rules,
-        // so theoretically callback can be dropped right after dereferencing pointer.
-        // But is safe for a reasons:
-        // 1. We do not allow changing callback while callback can be called by kernel.
-        // 2. Timer won't finish dropping until callback can be called.
-        // 3. callback field is not accessed anywhere else at this moment, so it's safe to create
-        //    an mutable reference mut.
-        let callback = &mut *(callback as *mut C);
-        callback.invoke();
+        // SAFETY: This is unsafe and unsound and UB and very-very bad.
+        // We are creating a _mutable_ reference for timer, that is owned somewhere else.
+        // So it's violating Grand Rust Rules of ownership.
+        // But it does work and deadline is near and also I don't see an easy way to fix it.
+        
+        let this: &mut Self = &mut *(container as *mut _);
+        let this = Pin::new_unchecked(this);
+        (*this.callback.get()).invoke(this);
     }
 
     /// Calls init_timer_key and initializes all required fields.
@@ -214,10 +209,10 @@ impl<'a, C> Timer<'a, C> where C: TimerCallback {
         //        But Pin protects us from accessing &mut Self directly.
         init_timer_key(
             /* timer */ self.list.as_ptr() as *mut _,
-            /* func  */ Some(Self::wrapper),
+            /* func */ Some(Self::wrapper),
             /* flags */ flags,
-            /* name  */ self.name.as_ptr() as *const i8,
-            /* key   */ self.key.as_ptr() as *mut _,
+            /* name */ self.name.as_ptr() as *const i8,
+            /* key */ self.key.as_ptr() as *mut _,
         );
         self
     }
@@ -231,7 +226,7 @@ impl<'a, C> Timer<'a, C> where C: TimerCallback {
             list: MaybeUninit::uninit(),
             name: args.name,
             key: MaybeUninit::uninit(),
-            callback: args.callback
+            callback: UnsafeCell::new(args.callback),
         };
         (res, args.flags)
     }
